<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ˜Ÿéš› 211 åå™¬è€… | æˆ‘çš„é¤ç›¤äº’å‹•éŠæˆ²</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #0f172a; /* Tailwind slate-900 */
            touch-action: none; /* é˜²æ­¢æ‰‹æ©Ÿæ»‘å‹•é é¢ */
        }
        canvas {
            display: block;
        }
        .glass-panel {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* éœ“è™¹æ–‡å­—æ•ˆæœ */
        .neon-text {
            color: #fff;
            text-shadow:
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px #0ea5e9,
                0 0 40px #0ea5e9;
        }
    </style>
</head>
<body>

    <!-- UI å±¤ -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-10">
        <!-- é ‚éƒ¨è³‡è¨Šåˆ— -->
        <div class="flex justify-between items-start">
            <div class="glass-panel p-3 rounded-xl text-white shadow-lg pointer-events-auto">
                <div class="text-sm text-slate-400">åˆ†æ•¸ SCORE</div>
                <div id="score-display" class="text-3xl font-black text-yellow-400">0</div>
            </div>
            
            <div class="glass-panel p-3 rounded-xl text-white shadow-lg text-center pointer-events-auto">
                <div class="text-sm text-slate-400">å‰©é¤˜æ™‚é–“ TIME</div>
                <div id="time-display" class="text-3xl font-black text-rose-400">60</div>
            </div>

            <div class="glass-panel p-3 rounded-xl text-white shadow-lg text-right pointer-events-auto">
                <div class="text-sm text-slate-400">ç­‰ç´š LEVEL</div>
                <div id="level-display" class="text-3xl font-black text-emerald-400">1</div>
            </div>
        </div>

        <!-- åº•éƒ¨æç¤ºåˆ— -->
        <div class="text-center mb-4">
            <div id="message-display" class="inline-block glass-panel px-6 py-2 rounded-full text-white font-bold text-lg opacity-0 transition-opacity duration-300">
                æ­¡è¿ä¾†åˆ°æ˜Ÿéš›ï¼
            </div>
        </div>
    </div>

    <!-- é–‹å§‹/çµæŸç•«é¢è¦†è“‹å±¤ -->
    <div id="overlay" class="absolute inset-0 bg-slate-900/90 flex items-center justify-center z-20 backdrop-blur-sm">
        <div class="max-w-md w-full p-8 glass-panel rounded-3xl text-center text-white border-2 border-slate-700 shadow-2xl">
            <h1 class="text-4xl font-black mb-2 neon-text tracking-wider">æ˜Ÿéš› 211 åå™¬è€…</h1>
            <p class="text-emerald-400 font-bold mb-6">æˆ‘çš„é¤ç›¤èƒ½é‡å¤§æŒ‘æˆ°</p>
            
            <div class="text-left space-y-4 mb-8 text-sm md:text-base">
                <p>ğŸ›¸ <b>ä»»å‹™ç›®æ¨™ï¼š</b> å¹«åŠ©æ³¢æ³¢æ”¶é›†å®‡å®™èƒ½é‡ï¼Œçµ„æˆå®Œç¾çš„ 211 é¤ç›¤ï¼</p>
                <div class="bg-slate-800 p-3 rounded-lg">
                    <p class="font-bold text-emerald-400 mb-1">ğŸŸ¢ è”¬èœ (ä½” 50%) - éœ€è¦ 4 ä»½</p>
                    <p class="text-xs text-slate-300">ğŸ¥¦ ğŸ¥• ğŸ… ğŸ¥¬ ğŸ† ğŸ„</p>
                </div>
                <div class="bg-slate-800 p-3 rounded-lg">
                    <p class="font-bold text-rose-400 mb-1">ğŸ”´ è±†é­šè›‹è‚‰ (ä½” 25%) - éœ€è¦ 2 ä»½</p>
                    <p class="text-xs text-slate-300">ğŸ— ğŸŸ ğŸ¥š ğŸ¥© ğŸ¦ ğŸ¦‘</p>
                </div>
                <div class="bg-slate-800 p-3 rounded-lg">
                    <p class="font-bold text-amber-400 mb-1">ğŸŸ¡ å…¨ç©€é›œç³§ (ä½” 25%) - éœ€è¦ 2 ä»½</p>
                    <p class="text-xs text-slate-300">ğŸš ğŸ  ğŸŒ½ ğŸ ğŸ¥” (æ³¨æ„ï¼šç‰ç±³é¦¬éˆ´è–¯æ˜¯æ¾±ç²‰å–”ï¼)</p>
                </div>
                <p>âœ¨ <b>éš±è—åŠ æˆï¼š</b> åƒåˆ°ä¹³å“ğŸ¥›æˆ–å …æœğŸ¥œå¯ç²å¾—ã€Œæˆ‘çš„é¤ç›¤ã€ç„¡æ•µè¡åˆºï¼</p>
                <p>âš ï¸ <b>å±éšªè­¦å‘Šï¼š</b> ç¢°åˆ°åƒåœ¾é£Ÿç‰©ğŸ”ğŸ¥¤æœƒæ‰£æ™‚é–“ï¼</p>
                <p class="text-center text-slate-400 text-xs pt-2">æ“ä½œæ–¹å¼ï¼šæ»‘é¼ ç§»å‹• æˆ– è§¸æ§æ»‘å‹•</p>
            </div>

            <button id="start-btn" class="w-full py-4 bg-gradient-to-r from-emerald-500 to-teal-500 hover:from-emerald-400 hover:to-teal-400 text-white font-black text-xl rounded-xl shadow-lg transform transition hover:scale-105 active:scale-95">
                é–‹å§‹ç™¼å°„ï¼
            </button>
        </div>
    </div>

    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * éŠæˆ²å¼•æ“èˆ‡é‚è¼¯
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('start-btn');
const scoreDisplay = document.getElementById('score-display');
const timeDisplay = document.getElementById('time-display');
const levelDisplay = document.getElementById('level-display');
const messageDisplay = document.getElementById('message-display');

// èª¿æ•´ç•«å¸ƒå¤§å°
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// --- éŠæˆ²è³‡æ–™åº« (Emoji é£Ÿç‰©) ---
const FOOD_TYPES = {
    VEG: { id: 'v', color: '#34d399', name: 'è”¬èœ', emojis: ['ğŸ¥¦', 'ğŸ¥•', 'ğŸ…', 'ğŸ¥¬', 'ğŸ†', 'ğŸ„', 'ğŸ§…', 'ğŸ¥’'], max: 4 },
    PRO: { id: 'p', color: '#fb7185', name: 'è›‹ç™½è³ª', emojis: ['ğŸ—', 'ğŸŸ', 'ğŸ¥š', 'ğŸ¥©', 'ğŸ¦', 'ğŸ¦‘', 'ğŸ¦', 'ğŸ¦€'], max: 2 },
    CARB: { id: 'c', color: '#fbbf24', name: 'å…¨ç©€é›œç³§', emojis: ['ğŸš', 'ğŸ ', 'ğŸŒ½', 'ğŸ', 'ğŸ¥”', 'ğŸœ', 'ğŸ¥', 'ğŸ¥Ÿ'], max: 2 },
    BONUS: { id: 'b', color: '#60a5fa', name: 'å¥åº·åŠ æˆ', emojis: ['ğŸ¥›', 'ğŸ¥œ', 'ğŸ§€', 'ğŸŒ°'] },
    JUNK: { id: 'j', color: '#94a3b8', name: 'åœ°é›·', emojis: ['ğŸ”', 'ğŸŸ', 'ğŸ¥¤', 'ğŸ°', 'ğŸ©', 'ğŸ«', 'ğŸ•', 'ğŸ¦'] }
};

// --- éŠæˆ²ç‹€æ…‹ ---
let gameState = {
    isRunning: false,
    score: 0,
    time: 60,
    level: 1,
    lastTime: 0,
    timerInterval: null
};

// --- å¯¦é«”é¡åˆ¥ ---

class Player {
    constructor() {
        this.radius = 40;
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.targetX = this.x;
        this.targetY = this.y;
        this.speed = 0.15; // ç·©å‹•è·Ÿéš¨æ»‘é¼ çš„é€Ÿåº¦
        this.inventory = { v: 0, p: 0, c: 0 };
        this.invincibleTimer = 0;
        this.rotation = 0;
    }

    update(dt) {
        // å¹³æ»‘ç§»å‹•åˆ°ç›®æ¨™ä½ç½® (Lerp)
        this.x += (this.targetX - this.x) * this.speed;
        this.y += (this.targetY - this.y) * this.speed;
        
        // é‚Šç•Œé™åˆ¶
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

        if (this.invincibleTimer > 0) {
            this.invincibleTimer -= dt;
        }
        this.rotation += 0.02;
    }

    draw(ctx) {
        // ç•«ç„¡æ•µå…‰ç’°
        if (this.invincibleTimer > 0) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 15 + Math.sin(Date.now()*0.01)*5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(96, 165, 250, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // ç•« 211 èƒ½é‡ç’° (ç”œç”œåœˆåœ–)
        const ringRadius = this.radius + 8;
        ctx.lineWidth = 12;

        // èƒŒæ™¯ç’°
        ctx.beginPath();
        ctx.arc(this.x, this.y, ringRadius, 0, Math.PI * 2);
        ctx.strokeStyle = '#334155';
        ctx.stroke();

        let currentAngle = -Math.PI / 2; // å¾æ­£ä¸Šæ–¹é–‹å§‹

        // ç•«è”¬èœ (ç›®æ¨™ 4/8 = 50% = 180åº¦)
        if (this.inventory.v > 0) {
            const vAngle = (this.inventory.v / 8) * (Math.PI * 2);
            ctx.beginPath();
            ctx.arc(this.x, this.y, ringRadius, currentAngle, currentAngle + vAngle);
            ctx.strokeStyle = FOOD_TYPES.VEG.color;
            ctx.stroke();
            currentAngle += vAngle;
        }

        // ç•«è›‹ç™½è³ª (ç›®æ¨™ 2/8 = 25% = 90åº¦)
        if (this.inventory.p > 0) {
            const pAngle = (this.inventory.p / 8) * (Math.PI * 2);
            ctx.beginPath();
            ctx.arc(this.x, this.y, ringRadius, currentAngle, currentAngle + pAngle);
            ctx.strokeStyle = FOOD_TYPES.PRO.color;
            ctx.stroke();
            currentAngle += pAngle;
        }

        // ç•«å…¨ç©€ (ç›®æ¨™ 2/8 = 25% = 90åº¦)
        if (this.inventory.c > 0) {
            const cAngle = (this.inventory.c / 8) * (Math.PI * 2);
            ctx.beginPath();
            ctx.arc(this.x, this.y, ringRadius, currentAngle, currentAngle + cAngle);
            ctx.strokeStyle = FOOD_TYPES.CARB.color;
            ctx.stroke();
        }

        // ç•«å¤–æ˜Ÿäººæœ¬é«”
        ctx.save();
        ctx.translate(this.x, this.y);
        
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#1e293b';
        ctx.fill();
        ctx.strokeStyle = '#cbd5e1';
        ctx.lineWidth = 3;
        ctx.stroke();

        // çœ¼ç›
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(-12, -10, 8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(12, -10, 8, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = '#000';
        // éš¨è‘—æ»‘é¼ æ–¹å‘è½‰å‹•çœ¼ç çš„ç°¡æ˜“æ¨¡æ“¬
        let eyeDx = (this.targetX - this.x) * 0.02;
        let eyeDy = (this.targetY - this.y) * 0.02;
        eyeDx = Math.max(-4, Math.min(4, eyeDx));
        eyeDy = Math.max(-4, Math.min(4, eyeDy));
        
        ctx.beginPath(); ctx.arc(-12 + eyeDx, -10 + eyeDy, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(12 + eyeDx, -10 + eyeDy, 4, 0, Math.PI*2); ctx.fill();

        // å˜´å·´ (åƒæ±è¥¿æ™‚å¼µé–‹)
        ctx.beginPath();
        ctx.arc(0, 10, 10, 0, Math.PI, false);
        ctx.fillStyle = '#ef4444';
        ctx.fill();

        ctx.restore();
    }
}

class Food {
    constructor(typeObj) {
        this.typeObj = typeObj;
        this.emoji = typeObj.emojis[Math.floor(Math.random() * typeObj.emojis.length)];
        this.radius = 20;
        
        // éš¨æ©Ÿå¾ç•«é¢é‚Šç·£ç”Ÿæˆ
        if (Math.random() > 0.5) {
            this.x = Math.random() > 0.5 ? -this.radius : canvas.width + this.radius;
            this.y = Math.random() * canvas.height;
        } else {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() > 0.5 ? -this.radius : canvas.height + this.radius;
        }

        // é£›å‘ç•«é¢ä¸­å¤®ç¨å¾®éš¨æ©Ÿçš„ä½ç½®
        const targetX = canvas.width/2 + (Math.random() - 0.5) * 300;
        const targetY = canvas.height/2 + (Math.random() - 0.5) * 300;
        const angle = Math.atan2(targetY - this.y, targetX - this.x);
        
        const speed = 1 + Math.random() * 2 + (gameState.level * 0.2); // éš¨ç­‰ç´šè®Šå¿«
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        
        this.rotation = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.1;
        this.markedForDeletion = false;
        
        // å‡ºç”Ÿä¿è­·æ™‚é–“ï¼Œé¿å…ä¸€å‡ºç”Ÿå°±è¢«åˆªé™¤
        this.lifeTime = 0;
    }

    update(dt) {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotSpeed;
        this.lifeTime += dt;

        // å¦‚æœé£›å‡ºè¢å¹•å¤ªé å‰‡åˆªé™¤
        if (this.lifeTime > 2000 && (this.x < -100 || this.x > canvas.width + 100 || this.y < -100 || this.y > canvas.height + 100)) {
            this.markedForDeletion = true;
        }
        
        // é‚Šç·£åå½ˆ (å¾®å¼±åå½ˆï¼Œè®“ä»–å¤šç•™åœ¨å ´ä¸Šä¸€æœƒå…’)
        if (this.x < 0 || this.x > canvas.width) this.vx *= -0.9;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -0.9;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // å¤–ç™¼å…‰
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.typeObj.color;
        
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji, 0, 0);
        
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, text) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4 - 2;
        this.life = 1.0;
        this.color = color;
        this.text = text;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.02;
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life);
        if (this.text) {
            ctx.font = 'bold 20px "Noto Sans TC"';
            ctx.fillStyle = this.color;
            ctx.textAlign = 'center';
            ctx.fillText(this.text, this.x, this.y);
        } else {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        ctx.restore();
    }
}

// --- éŠæˆ²è®Šæ•¸ ---
let player;
let foods = [];
let particles = [];
let foodSpawnTimer = 0;

// --- è¼¸å…¥è™•ç† ---
function updateTarget(e) {
    if (!gameState.isRunning) return;
    e.preventDefault();
    if (e.touches && e.touches.length > 0) {
        player.targetX = e.touches[0].clientX;
        player.targetY = e.touches[0].clientY;
    } else {
        player.targetX = e.clientX;
        player.targetY = e.clientY;
    }
}
window.addEventListener('mousemove', updateTarget);
window.addEventListener('touchmove', updateTarget, {passive: false});
window.addEventListener('touchstart', updateTarget, {passive: false});

// --- UI æç¤ºæ–‡å­— ---
function showMessage(text, colorClass = 'text-white') {
    messageDisplay.textContent = text;
    messageDisplay.className = `inline-block glass-panel px-6 py-2 rounded-full font-bold text-lg transition-opacity duration-300 ${colorClass} opacity-100`;
    
    // æ¸…é™¤èˆŠçš„ timeout
    if (window.msgTimeout) clearTimeout(window.msgTimeout);
    window.msgTimeout = setTimeout(() => {
        messageDisplay.classList.remove('opacity-100');
        messageDisplay.classList.add('opacity-0');
    }, 1500);
}

function spawnParticles(x, y, color, text = null, count = 5) {
    if (text) {
        particles.push(new Particle(x, y, color, text));
    }
    for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color, null));
    }
}

// --- æ ¸å¿ƒé‚è¼¯ ---

function check211Complete() {
    if (player.inventory.v === 4 && player.inventory.p === 2 && player.inventory.c === 2) {
        // å®Œç¾ 211 é¤ç›¤ï¼
        gameState.score += 500;
        gameState.level++;
        gameState.time += 15; // çå‹µæ™‚é–“
        
        player.inventory = { v: 0, p: 0, c: 0 }; // æ¸…ç©ºæº–å‚™ä¸‹ä¸€ç›¤
        
        showMessage("ğŸŒŸ å®Œç¾ 211 é¤ç›¤ï¼ç­‰ç´šæå‡ï¼", "text-yellow-400");
        spawnParticles(player.x, player.y, '#fbbf24', 'LEVEL UP!', 20);
        
        updateUI();
        return true;
    }
    return false;
}

function handleEating(food) {
    const type = food.typeObj;
    
    if (type.id === 'j') {
        // åƒåˆ°åƒåœ¾é£Ÿç‰©
        if (player.invincibleTimer > 0) {
            spawnParticles(food.x, food.y, '#fff', 'ç„¡æ•µå½ˆé–‹ï¼');
            return false; // ç„¡æ•µç‹€æ…‹å½ˆé–‹
        } else {
            gameState.time -= 5;
            gameState.score = Math.max(0, gameState.score - 50);
            showMessage("âš ï¸ åƒåˆ°åƒåœ¾é£Ÿç‰©ï¼æ‰£ 5 ç§’ï¼", "text-red-500");
            spawnParticles(food.x, food.y, type.color, 'ğŸ’”', 10);
            updateUI();
            
            // ç•«é¢éœ‡å‹•æ•ˆæœ (ç°¡å–®å¯¦ä½œ)
            ctx.translate((Math.random()-0.5)*20, (Math.random()-0.5)*20);
            setTimeout(() => ctx.setTransform(1, 0, 0, 1, 0, 0), 50);
            return true;
        }
    }

    if (type.id === 'b') {
        // æˆ‘çš„é¤ç›¤åŠ æˆ (ä¹³å“/å …æœ)
        player.invincibleTimer = 5000; // 5ç§’ç„¡æ•µ
        gameState.score += 100;
        showMessage("ğŸ¥› ç²å¾—æˆ‘çš„é¤ç›¤å¥åº·é˜²è­·ç½©ï¼", "text-blue-400");
        spawnParticles(food.x, food.y, type.color, 'ç„¡æ•µï¼', 15);
        updateUI();
        return true;
    }

    // è™•ç† 211 é£Ÿç‰©
    if (player.inventory[type.id] < type.max) {
        player.inventory[type.id]++;
        gameState.score += 10;
        spawnParticles(food.x, food.y, type.color, `+1 ${type.name}`);
        updateUI();
        check211Complete();
        return true;
    } else {
        // è©²é¡åˆ¥å·²æ»¿
        showMessage(`ğŸ›‘ ${type.name}å·²ç¶“å¤ å›‰ï¼`, "text-slate-300");
        // æŠŠé£Ÿç‰©å½ˆé–‹
        food.vx *= -1.5;
        food.vy *= -1.5;
        return false;
    }
}

// --- éŠæˆ²è¿´åœˆ ---

function gameLoop(timestamp) {
    if (!gameState.isRunning) return;

    const dt = timestamp - gameState.lastTime;
    gameState.lastTime = timestamp;

    // æ¸…é™¤ç•«å¸ƒ
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ç•«èƒŒæ™¯ç¶²æ ¼ (å¢åŠ å¤ªç©ºæ„Ÿ)
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    const gridSize = 100;
    const offsetX = (Date.now() * 0.02) % gridSize;
    const offsetY = (Date.now() * 0.02) % gridSize;
    
    ctx.beginPath();
    for(let x = offsetX; x < canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
    for(let y = offsetY; y < canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
    ctx.stroke();

    // æ›´æ–°èˆ‡ç¹ªè£½ç©å®¶
    player.update(dt);
    player.draw(ctx);

    // ç”Ÿæˆé£Ÿç‰©
    foodSpawnTimer -= dt;
    if (foodSpawnTimer <= 0) {
        const spawnRate = Math.max(200, 1000 - (gameState.level * 50)); // éš¨ç­‰ç´šåŠ å¿«ç”Ÿæˆ
        foodSpawnTimer = spawnRate;
        
        // éš¨æ©Ÿæ±ºå®šç”Ÿæˆç¨®é¡ (æ©Ÿç‡æ§åˆ¶)
        const rand = Math.random();
        let selectedType;
        if (rand < 0.3) selectedType = FOOD_TYPES.VEG;       // 30% è”¬èœ (å› ç‚ºéœ€è¦4ä»½ï¼Œæ©Ÿç‡é«˜é»)
        else if (rand < 0.5) selectedType = FOOD_TYPES.PRO;  // 20% è›‹ç™½
        else if (rand < 0.7) selectedType = FOOD_TYPES.CARB; // 20% æ¾±ç²‰
        else if (rand < 0.8) selectedType = FOOD_TYPES.BONUS;// 10% é“å…·
        else selectedType = FOOD_TYPES.JUNK;                 // 20% åƒåœ¾é£Ÿç‰©

        foods.push(new Food(selectedType));
    }

    // æ›´æ–°èˆ‡ç¹ªè£½é£Ÿç‰©ï¼Œä¸¦é€²è¡Œç¢°æ’åµæ¸¬
    for (let i = foods.length - 1; i >= 0; i--) {
        let f = foods[i];
        f.update(dt);
        f.draw(ctx);

        // åœ“å½¢ç¢°æ’åµæ¸¬
        const dx = player.x - f.x;
        const dy = player.y - f.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < player.radius + f.radius) {
            // ç™¼ç”Ÿç¢°æ’
            const eaten = handleEating(f);
            if (eaten) {
                f.markedForDeletion = true;
            }
        }

        if (f.markedForDeletion) {
            foods.splice(i, 1);
        }
    }

    // æ›´æ–°èˆ‡ç¹ªè£½ç²’å­
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.update();
        p.draw(ctx);
        if (p.life <= 0) particles.splice(i, 1);
    }

    requestAnimationFrame(gameLoop);
}

function updateUI() {
    scoreDisplay.textContent = gameState.score;
    levelDisplay.textContent = gameState.level;
    timeDisplay.textContent = Math.ceil(gameState.time);
}

// è¨ˆæ™‚å™¨é‚è¼¯
function startTimer() {
    if (gameState.timerInterval) clearInterval(gameState.timerInterval);
    gameState.timerInterval = setInterval(() => {
        if (!gameState.isRunning) return;
        
        gameState.time -= 1;
        updateUI();

        if (gameState.time <= 0) {
            gameOver();
        }
    }, 1000);
}

function startGame() {
    overlay.classList.add('hidden');
    
    // åˆå§‹åŒ–ç‹€æ…‹
    player = new Player();
    foods = [];
    particles = [];
    gameState.score = 0;
    gameState.time = 60;
    gameState.level = 1;
    gameState.isRunning = true;
    gameState.lastTime = performance.now();
    
    updateUI();
    startTimer();
    showMessage("éŠæˆ²é–‹å§‹ï¼å¿«åƒè”¬èœï¼");
    
    requestAnimationFrame(gameLoop);
}

function gameOver() {
    gameState.isRunning = false;
    clearInterval(gameState.timerInterval);
    
    overlay.classList.remove('hidden');
    overlay.innerHTML = `
        <div class="max-w-md w-full p-8 glass-panel rounded-3xl text-center text-white border-2 border-slate-700 shadow-2xl">
            <h1 class="text-4xl font-black mb-4 text-rose-500">æ™‚é–“åˆ°ï¼</h1>
            <p class="text-xl mb-2">ä½ çš„æœ€çµ‚åˆ†æ•¸</p>
            <div class="text-6xl font-black text-yellow-400 mb-6">${gameState.score}</div>
            <p class="mb-6 text-slate-300">æˆåŠŸé”æˆ <span class="text-emerald-400 font-bold">${gameState.level - 1}</span> æ¬¡å®Œç¾ 211 é¤ç›¤ï¼</p>
            <button onclick="location.reload()" class="w-full py-4 bg-gradient-to-r from-emerald-500 to-teal-500 hover:from-emerald-400 hover:to-teal-400 text-white font-black text-xl rounded-xl shadow-lg transform transition hover:scale-105 active:scale-95">
                å†ç©ä¸€æ¬¡
            </button>
        </div>
    `;
}

startBtn.addEventListener('click', startGame);

</script>
</body>
</html>